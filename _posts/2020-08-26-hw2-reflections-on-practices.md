---
layout: post
title:  "HW2: Reflections on Software Engineering Practices"
date:   2020-08-26 17:39:41 -0400
categories: Software Engineering Homework
---


  Software development takes time, especially large projects, or developing complex systems. There are several limiting factors regarding software development, and expediting or even automating the process. A massive amount of discussion, research, and projects revolved around evolving into the adapting technological landscape. The exponential growth of products and services that became available in an astonishingly small amount of time was met with a ubiquitous hustle to adapt software practices to meet the everchanging needs of system designs and implementations. 



  No Silver Bullet, Kode Vicious, and Google Code Repo concern the intricacies of software development. From the concept of there not being a “silver bullet”, an idea, or development that propels software development processes miles ahead, to good practices when developing projects. In addition to a situation where a company had to continuously scale in order to support its growing infrastructure.



  One idea that commonly occurs between these three articles, is the fact that any development takes time. Not just to develop, or grow the software as No Silver Bullet says, but to plan the software. A plethora of prerequisites need to be checked off a list before a single line of code is written. There are infinitely many things to consider when beginning to grow a project. Most notable of these being planning, designing, and strategizing with other domain experts. Subsequently scrutinizing these ideas, and revising them.



  Additionally, it is emphasized in No Silver Bullet, that software code is malleable; that it constantly changes. The need for adaptability in software design is nothing less than crucial. Between Google slowly growing and adapting their infrastructure, to changing the habits that one employs during project development, enabling the daunting task of merging one’s work more digestible through consistency and punctuality. Every aspect of software development must be malleable.



  In Kode Vicious, the writer remarks on the importance of having extensive, tangible notes detailing one’s work. It’s declared that this is not just good practice, but this is a necessary preface to holding oneself accountable for their work and maintaining knowledge of how the system is being developed. This advice can be seen in action, and as a great success, by observing Google’s development process. As detailed in Google Code Repo, Google uses ‘trunk-based development’. This practice allows developers to constantly add to the ‘trunk’, instead of having to occasionally go through the hassle of merging large amounts of code and making sure it gets integrated properly. Additionally, their system provides personal accountability, because every area that developers are responsible for, can be directly traced back to them. The process of adding code to a branch that one is not responsible for involves personal review by the branch managers before being integrated into the system, which allows for accountability and also helps protect the system from unsavory actions.



  As most things do when they become larger, they also become more complex. This is evident in observing Google’s constant and exponential growth, as explained in Google Code Repo. A question that might occur to one when considering the astronomical feat that Google accomplished, is how? Fortunately, No Silver Bullet discusses ideas that are relevant to understanding this question, and a massive portion of that success can be attributed to communication. Open communication allows people enmeshed in complex systems to maintain an understanding of their duties, as well as what is expected of them. One of the biggest and most evident themes between all of these articles is the absolute, undeniable need for open, clear, and constant communication between developers, managers, clients, and anyone else involved in the prospective success of the software.



  Ultimately, these articles articulate the principal complexities surrounding the conception and subsequent evolution of software design practices and their systems.
